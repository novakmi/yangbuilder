//This is free software licensed under MIT License, see LICENSE file
//(https://bitbucket.org/novakmi/yangbuilder/src/LICENSE)

// For running Gradle, add GRADLE_HOME/bin to PATH
// Tip: Use Intellij Idea community edition to work with gradle (GradleGUI plugin)
// run 'gradle tasks' to see available tasks

apply plugin: 'groovy'
apply plugin: 'maven' // to use maven repository
apply plugin: 'idea' // to generate project+module files for Intellij Idea

version = '1.1.0'
sourceCompatibility = '1.6'
def groupId = "org.bitbucket.novakmi"
def installDir = file("${project.projectDir}/install")
def documentationDir = file("${project.projectDir}/documentation")

idea {
        module {
                downloadJavadoc = true
        }
}

repositories {
        maven { url "https://jcenter.bintray.com" } //jcenter repo
        mavenCentral() // standard maven repository
}

// Define dependencies
dependencies {
        compile group: 'org.codehaus.groovy', name: 'groovy-all', version: '2.4.1'
        compile group: 'org.bitbucket.novakmi', name: 'nodebuilder', version: '0.9.0'
        // dependencies for tests
        testCompile group: 'org.slf4j', name: 'slf4j-api', version: '1.7.9'
        testCompile group: 'org.testng', name: 'testng', version: '6.8.8'
        testCompile group: 'ch.qos.logback', name: 'logback-classic', version: '1.1.2'
        //testCompile 'org.uncommons:reportng:1.1.1'
        testCompile group: 'janino', name: 'janino', version: '2.4.3'
}


jar {
        manifest {
                attributes(
                        'Implementation-Title': project.name,
                        'Implementation-Version': version,
                        'Specification-Vendor': 'Michal Novak (it.novakmi@gmail.com)',
                        'Built-By': 'novakmi',
                        'Specification-Title': project.name,
                        'Extension-Name': project.name,
                        'Specification-Version': version
                )
        }
}

clean << {  //add to clean task
        installDir.deleteDir()
        ant.delete (includeEmptyDirs: 'false') { // todo gradle delete?
                fileset(dir: documentationDir, includes: '*.tmp')
        }
}

task sourcesJar(type: Jar) {
        classifier = 'sources'
        from "${project.projectDir}/src/main"
}

task groovydocJar(type: Jar, dependsOn: groovydoc) {
        classifier = 'groovydoc'
        from groovydoc.destinationDir
}

test {
        useTestNG() {
                suiteXmlBuilder().suite(name: 'Test yang groovy builder') {
                        test(name: 'yang'/*, annotations: 'JDK', verbose: '1'*/) {
                                groups {
                                        run {
                                                include(name: "basic")
                                        }
                                }
                                classes([:]) {
                                        'class'(name: "org.bitbucket.novakmi.test.yangbuilder.YangBuilderTest")
                                        'class'(name: "org.bitbucket.novakmi.test.yangbuilder.CompactYangPluginTest")
                                }
                        }
                }
        }
//    options {
        //        listeners << 'org.uncommons.reportng.HTMLReporter'
        //        listeners << 'org.uncommons.reportng.JUnitXMLReporter'
        //    }
}


task prepareInstall(type: Copy, dependsOn: [jar, sourcesJar, groovydocJar]) {
        installDir.mkdirs()
        //logger.quiet("externalJars {}", externalJars)
        from configurations['compile']?.files/*?.findAll { it.absolutePath.indexOf('unspecified') < 0 }*/
        from "${project.projectDir}/build/libs"
        into installDir
}

// zip into build/distributions
task zipInstall(type: Zip, dependsOn: prepareInstall) {
        from installDir.toString()
}

artifacts { // upload also sources and groovydoc
        archives sourcesJar
        archives groovydocJar
}

uploadArchives { // support to upload to github emulated maven repository
        def localMavenDir = System.getenv()['LOCAL_MAVEN_DIR']
        if (!localMavenDir) {
                logger.error("LOCAL_MAVEN_DIR is not defined! Artifacts will not be exported!")
        } else {
                repositories {
                        mavenDeployer {
                                repository(url: "file://localhost/${localMavenDir}/releases")
                                pom.version = version
                                pom.groupId = groupId
                        }
                }
        }
}

def runSh(cmd) {
        def proc = cmd.execute()
        proc.waitFor()
        def out = proc.in.text
        if (proc.exitValue()) {
                logger.error("Error running command:")
                logger.error(cmd)
                logger.error "return code: ${ proc.exitValue()}"
                logger.error "stderr: ${proc.err.text}"
                logger.error "stdout: ${out}" // *out* from the external program is *in*
                throw new GradleException("Error running command: ${cmd}")
        }
        return out
}

def linesBetween(inFile, outFile, line1, line2, skipList = ['#$#'],
                 replaceMap = ['*<*':'<', '*>*':'>']) {
        def exec = "/usr/bin/awk /${line2}/{flag=0}flag;/${line1}/{flag=1} ${inFile}"
        logger.debug("exec {}", exec)
        def out = runSh(exec)
        def finalOut = ''
        out.eachLine {line ->
                def skipped = false
                if (skipList) {
                        for(skip in skipList) {
                                if (line.contains(skip)) {
                                        skipped = true
                                        break
                                }
                        }
                }
                if (!skipped) {
                        if (replaceMap) {
                                replaceMap.each { k, v ->
                                        line = line.replace(k,v)
                                }
                        }
                        finalOut += line + '\n'
                }
        }
        logger.debug(out)
        new File(outFile).write(finalOut)
}

task documentation(dependsOn: compileGroovy) << {
        File buildDirDocumentation = new File(buildDir.toString() + '/documentation')
        def templatesDir = "${project.projectDir}/templates"
        def docDir = "${documentationDir.toString()}"

        buildDirDocumentation.mkdirs()

        //run script files
        Binding binding = new Binding();
        def urls = configurations.runtime.collect { it.toURI().toURL() }
        urls += new URL("file://${buildDir}/classes/main")
        //urls += new URL("file://${buildDir}/libs/yangbuilder-1.0.0.jar")

        def cp = ''
        urls.each { u ->
                logger.info(u as String)
                cp += u as String
                cp +=":"
        }

        logger.debug("Evaluating scripts")
        def sdir = "${templatesDir}/scripts"
        logger.info("Running: groovy -cp ${cp} ${sdir}/acmeYang.groovy")
        runSh("groovy -cp ${cp} ${sdir}/acmeYang.groovy")
        runSh("groovy -cp ${cp} ${sdir}/exampleYang.groovy")
        runSh("groovy -cp ${cp} ${sdir}/exampleCompactYang.groovy")

        logger.debug("Evaluating scripts done")
        runSh("mv ${project.projectDir}/acme-module.yang ${docDir}/acme-module_.tmp")
        runSh("mv ${project.projectDir}/example-module.yang ${docDir}/example-module_.tmp")
        runSh("mv ${project.projectDir}/example-compact-module.yang ${docDir}/example-compact-module_.tmp")

        // prepare include files from groovy source files
        linesBetween("${project.projectDir}/LICENSE", "${docDir}/LICENSE.tmp", "-----", "-----")
        linesBetween("${templatesDir}/scripts/acmeYang.groovy", "${docDir}/acmeYang.tmp", "adoc-begin", "adoc-callout")
        linesBetween("${templatesDir}/scripts/acmeYang.groovy", "${docDir}/acmeYang-callout.tmp", "adoc-callout", "adoc-end")
        linesBetween("${templatesDir}/scripts/exampleYang.groovy", "${docDir}/exampleYang.tmp", "adoc-begin", "adoc-callout")
        linesBetween("${templatesDir}/scripts/exampleYang.groovy", "${docDir}/exampleYang-callout.tmp", "adoc-callout", "adoc-end")
        linesBetween("${templatesDir}/scripts/exampleCompactYang.groovy", "${docDir}/exampleCompactYang.tmp", "adoc-begin", "adoc-callout")
        linesBetween("${templatesDir}/scripts/exampleCompactYang.groovy", "${docDir}/exampleCompactYang-callout.tmp", "adoc-callout", "adoc-end")

        // prepare inlcude files from generated yang files
        linesBetween("${docDir}/acme-module_.tmp", "${docDir}/acme-module.tmp", "adocy-begin", "adocy-callout")
        linesBetween("${docDir}/acme-module_.tmp", "${docDir}/acme-module-callout.tmp", "adocy-callout", "adocy-end")
        linesBetween("${docDir}/example-module_.tmp", "${docDir}/example-module.tmp", "adocy-begin", "adocy-callout")
        linesBetween("${docDir}/example-module_.tmp", "${docDir}/example-module-callout.tmp", "adocy-callout", "adocy-end")
        linesBetween("${docDir}/example-compact-module_.tmp", "${docDir}/example-compact-module-callout.tmp", "adocy-callout", "adocy-end")

        // asciidoc has to be installed
        def cmd = 'asciidoc -d article -a data-uri -a icons -a iconsdir=/usr/share/asciidoc/images/icons -a toc -a max-width=55em'
        cmd += " -o  ${buildDirDocumentation.toString()}/yangbuilder.html"
        cmd += " ${docDir}/yangbuilder.asciidoc"
        runSh(cmd)

        // delete generated files
        //delete(fileTree(documentationDir.toString()).include('**/*.tmp'))
}
// http://daniel.gredler.net/2011/08/08/gradle-keeping-libraries-up-to-date/
// Find any 3rd party libraries which have released new versions
// to the central Maven repository since we last upgraded.
task checkLibVersions << {
        def checked = [:]
        allprojects {
                configurations.each { configuration ->
                        configuration.allDependencies.each { dependency ->
                                def ver = dependency.version
                                if (ver && !ver.contains('SNAPSHOT') && !checked[dependency]) {
                                        def group = dependency.group
                                        def path = group.replace('.', '/')
                                        def name = dependency.name
                                        def url = "http://repo1.maven.org/maven2/$path/$name/maven-metadata.xml"
                                        try {
                                                def metadata = new XmlSlurper().parseText(url.toURL().text)
                                                def versions = metadata.versioning.versions.version.collect { it.text() }
                                                versions.removeAll { it.toLowerCase().contains('alpha') }
                                                versions.removeAll { it.toLowerCase().contains('beta') }
                                                versions.removeAll { it.toLowerCase().contains('rc') }
                                                def newest = versions.max()
                                                if (ver != newest) {
                                                        println "$group:$name $ver -> $newest [$versions]"
                                                }
                                        } catch (FileNotFoundException e) {
                                                logger.debug "Unable to download $url: $e.message"
                                        } catch (org.xml.sax.SAXParseException e) {
                                                logger.debug "Unable to parse $url: $e.message"
                                        }
                                        checked[dependency] = true
                                }
                        }
                }
        }
}