//This is free software licensed under MIT License, see LICENSE file
//(https://bitbucket.org/novakmi/yangbuilder/src/LICENSE)

// For running Gradle, add GRADLE_HOME/bin to PATH
// Tip: Use Intellij Idea community edition to work with gradle (GradleGUI plugin)
// run 'gradle tasks' to see available tasks

apply plugin: 'groovy'
apply plugin: 'maven' // to use maven repository
apply plugin: 'idea' // to generate project+module files for Intellij Idea

version = '1.2.1'
sourceCompatibility = '1.6'
def groupId = "org.bitbucket.novakmi"
def installDir = file("${project.projectDir}/install")
def documentationDir = file("${project.projectDir}/documentation")

idea {
        module {
                downloadJavadoc = true
        }
}

repositories {
        maven { url "https://jcenter.bintray.com" } //jcenter repo
        mavenCentral() // standard maven repository
}

// Define dependencies
dependencies {
        compile localGroovy()
        compile group: 'org.bitbucket.novakmi', name: 'nodebuilder', version: '1.0.0'
        // dependencies for tests
        testCompile group: 'org.slf4j', name: 'slf4j-api', version: '1.7.9'
        testCompile group: 'org.testng', name: 'testng', version: '6.9.9'
        testCompile group: 'ch.qos.logback', name: 'logback-classic', version: '1.2.1'
        //testCompile 'org.uncommons:reportng:1.1.1'
        testCompile group: 'janino', name: 'janino', version: '2.4.3'
}


jar {
        manifest {
                attributes(
                        'Implementation-Title': project.name,
                        'Implementation-Version': version,
                        'Specification-Vendor': 'Michal Novak (it.novakmi@gmail.com)',
                        'Built-By': 'novakmi',
                        'Specification-Title': project.name,
                        'Extension-Name': project.name,
                        'Specification-Version': version
                )
        }
}

clean << {  //add to clean task
        installDir.deleteDir()
        ant.delete (includeEmptyDirs: 'false') { // todo gradle delete?
                fileset(dir: documentationDir, includes: '*.tmp')
        }
}

task sourcesJar(type: Jar) {
        classifier = 'sources'
        from "${project.projectDir}/src/main"
}

task groovydocJar(type: Jar, dependsOn: groovydoc) {
        classifier = 'groovydoc'
        from groovydoc.destinationDir
}

test {
        useTestNG() {
                suiteXmlBuilder().suite(name: 'Test yang groovy builder') {
                        test(name: 'yang'/*, annotations: 'JDK', verbose: '1'*/) {
                                groups {
                                        run {
                                                include(name: "basic")
                                        }
                                }
                                classes([:]) {
                                        'class'(name: "org.bitbucket.novakmi.test.yangbuilder.YangBuilderTest")
                                        'class'(name: "org.bitbucket.novakmi.test.yangbuilder.CompactYangPluginTest")
                                }
                        }
                }
        }
//    options {
        //        listeners << 'org.uncommons.reportng.HTMLReporter'
        //        listeners << 'org.uncommons.reportng.JUnitXMLReporter'
        //    }
}


task prepareInstall(type: Copy, dependsOn: [jar, sourcesJar, groovydocJar]) {
        installDir.mkdirs()
        //logger.quiet("externalJars {}", externalJars)
        from configurations['compile']?.files/*?.findAll { it.absolutePath.indexOf('unspecified') < 0 }*/
        from "${project.projectDir}/build/libs"
        into installDir
}

// zip into build/distributions
task zipInstall(type: Zip, dependsOn: prepareInstall) {
        from installDir.toString()
}

artifacts { // upload also sources and groovydoc
        archives sourcesJar
        archives groovydocJar
}

uploadArchives { // support to upload to github emulated maven repository
        def localMavenDir = System.getenv()['LOCAL_MAVEN_DIR']
        if (!localMavenDir) {
                logger.error("LOCAL_MAVEN_DIR is not defined! Artifacts will not be exported!")
        } else {
                repositories {
                        mavenDeployer {
                                repository(url: "file://localhost/${localMavenDir}/releases")
                                pom.version = version
                                pom.groupId = groupId
                        }
                }
        }
}

def runSh(cmd) {
        def proc = cmd.execute()
        proc.waitFor()
        def out = proc.in.text
        if (proc.exitValue()) {
                logger.error("Error running command:")
                logger.error(cmd)
                logger.error "return code: ${ proc.exitValue()}"
                logger.error "stderr: ${proc.err.text}"
                logger.error "stdout: ${out}" // *out* from the external program is *in*
                throw new GradleException("Error running command: ${cmd}")
        }
        return out
}

// http://daniel.gredler.net/2011/08/08/gradle-keeping-libraries-up-to-date/
// Find any 3rd party libraries which have released new versions
// to the central Maven repository since we last upgraded.
task checkLibVersions << {
        def checked = [:]
        allprojects {
                configurations.each { configuration ->
                        configuration.allDependencies.each { dependency ->
                                def ver = dependency.version
                                if (ver && !ver.contains('SNAPSHOT') && !checked[dependency]) {
                                        def group = dependency.group
                                        def path = group.replace('.', '/')
                                        def name = dependency.name
                                        def url = "http://repo1.maven.org/maven2/$path/$name/maven-metadata.xml"
                                        try {
                                                def metadata = new XmlSlurper().parseText(url.toURL().text)
                                                def versions = metadata.versioning.versions.version.collect { it.text() }
                                                versions.removeAll { it.toLowerCase().contains('alpha') }
                                                versions.removeAll { it.toLowerCase().contains('beta') }
                                                versions.removeAll { it.toLowerCase().contains('rc') }
                                                def newest = versions.max()
                                                if (ver != newest) {
                                                        println "$group:$name $ver -> $newest [$versions]"
                                                }
                                        } catch (FileNotFoundException e) {
                                                logger.debug "Unable to download $url: $e.message"
                                        } catch (org.xml.sax.SAXParseException e) {
                                                logger.debug "Unable to parse $url: $e.message"
                                        }
                                        checked[dependency] = true
                                }
                        }
                }
        }
}