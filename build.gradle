//This is free software licensed under MIT License, see LICENSE file
//(https://bitbucket.org/bubbles.way/yangbuilder/src/LICENSE)

// For running Gradle, add GRADLE_HOME/bin to PATH, NCS_DIR has to be defined
// Tip: Use Intellij Idea community edition to work with gradle (GradleGUI plugin)
// run 'gradle tasks' to see available tasks

apply plugin: 'groovy'
apply plugin: 'maven' // to use maven repository
apply plugin: 'idea' // to generate project+module files for Intellij Idea

version = '0.3.3'
sourceCompatibility = '1.6'
def groupId = "org.bitbucket.novakmi"
def installDir = file("${project.projectDir}/install")
def documentationDir = file("${project.projectDir}/documentation")

idea {
        module {
                downloadJavadoc = true
        }
}

repositories {
        mavenCentral() // standard maven repository
        mavenRepo(name: 'bubbleswayrepo', url: 'https://github.com/bubblesway/bubbleswayrepo/raw/master/releases')
}

// Define dependencies
dependencies {
        groovy group: 'org.codehaus.groovy', name: 'groovy-all', version: '1.8.6'
        compile group: 'org.bitbucket.novakmi', name: 'nodebuilder', version: '0.5.0'
        // dependencies for tests
        testCompile group: 'org.slf4j', name: 'slf4j-api', version: '1.6.4'
        testCompile group: 'org.testng', name: 'testng', version: '6.4'
        testCompile group: 'ch.qos.logback', name: 'logback-classic', version: '1.0.1'
        //testCompile 'org.uncommons:reportng:1.1.1'
        testCompile group: 'janino', name: 'janino', version: '2.5.10'
}


jar {
        manifest {
                attributes(
                        'Implementation-Title': project.name,
                        'Implementation-Version': version,
                        'Specification-Vendor': 'Michal Novak (bubbles.way@gmail.com)',
                        'Built-By': 'bubbles.way',
                        'Specification-Title': project.name,
                        'Extension-Name': project.name,
                        'Specification-Version': version
                )
        }
}

clean << {  //add to clean task
        installDir.deleteDir()
}

task sourcesJar(type: Jar) {
        classifier = 'sources'
        from "${project.projectDir}/src/main"
}

task groovydocJar(type: Jar, dependsOn: groovydoc) {
        classifier = 'groovydoc'
        from groovydoc.destinationDir
}

test {
        useTestNG() {
                suiteXmlBuilder().suite(name: 'Test yang groovy builder') {
                        test(name: 'yang'/*, annotations: 'JDK', verbose: '1'*/) {
                                groups {
                                        run {
                                                include(name: "basic")
                                        }
                                }
                                classes([:]) {
                                        'class'(name: "org.bitbucket.novakmi.test.yangbuilder.YangBuilderTest")
                                }
                        }
                }
        }
//    options {
        //        listeners << 'org.uncommons.reportng.HTMLReporter'
        //        listeners << 'org.uncommons.reportng.JUnitXMLReporter'
        //    }
}


task prepareInstall(type: Copy, dependsOn: [jar, sourcesJar, groovydocJar]) {
        installDir.mkdirs()
        //logger.quiet("externalJars {}", externalJars)
        from configurations['compile']?.files/*?.findAll { it.absolutePath.indexOf('unspecified') < 0 }*/
        from "${project.projectDir}/build/libs"
        into installDir
}

// zip into build/distributions
task zipInstall(type: Zip, dependsOn: prepareInstall) {
        from installDir.toString()
}

artifacts { // upload also sources and groovydoc
        archives sourcesJar
        archives groovydocJar
}

uploadArchives { // support to upload to github emulated maven repository
        def localMavenDir = System.getenv()['LOCAL_MAVEN_DIR']
        if (!localMavenDir) {
                logger.error("LOCAL_MAVEN_DIR is not defined! Artifacts will not be exported!")
        } else {
                repositories {
                        mavenDeployer {
                                repository(url: "file://localhost/${localMavenDir}/releases")
                                pom.version = version
                                pom.groupId = groupId
                        }
                }
        }
}

def linesBetween(inFile, outFile, line1, line2, skipList = ['#$#'],
                 replaceMap = ['*<*':'<', '*>*':'>']) {
        def exec = "/usr/bin/awk /${line2}/{flag=0}flag;/${line1}/{flag=1} ${inFile}"
        logger.debug("exec {}", exec)
        def proc = exec.execute()
        proc.waitFor()
        def out = proc.in.text
        if (proc.exitValue()) {
                logger.error "return code: ${ proc.exitValue()}"
                logger.error "stderr: ${proc.err.text}"
                logger.error "stdout: ${out}" // *out* from the external program is *in*
        } else {
                def finalOut = ''
                out.eachLine {line ->
                        def skipped = false
                        if (skipList) {
                                for(skip in skipList) {
                                        if (line.contains(skip)) {
                                                skipped = true
                                                break
                                        }
                                }
                        }
                        if (!skipped) {
                                if (replaceMap) {
                                        replaceMap.each { k, v ->
                                                line = line.replace(k,v)
                                        }
                                }
                                finalOut += line + '\n'
                        }
                }
                logger.debug(out)
                new File(outFile).write(finalOut)
        }
}

task documentation << {
        File buildDirDocumentation = new File(buildDir.toString() + '/documentation')
        def templatesDir = "${project.projectDir}/templates"
        def docDir = "${documentationDir.toString()}"

        buildDirDocumentation.mkdirs()

        //run script files
        Binding binding = new Binding();
        GroovyScriptEngine gse = new GroovyScriptEngine("${templatesDir}/scripts");
        logger.debug("Evaluating scripts")
        gse.run("acmeYang.groovy", binding);
        gse.run("example1Yang.groovy", binding);
        logger.debug("Evaluating scripts done")
        "mv ${project.projectDir}/acme-module.yang ${docDir}/acme-module_.tmp".execute().waitFor()
        "mv ${project.projectDir}/example1-module.yang ${docDir}/example1-module_.tmp".execute().waitFor()

        // prepare include files from groovy source files
        linesBetween("${project.projectDir}/LICENSE", "${docDir}/LICENSE.tmp", "-----", "-----")
        linesBetween("${templatesDir}/scripts/acmeYang.groovy", "${docDir}/acmeYang.tmp", "adoc-begin", "adoc-callout")
        linesBetween("${templatesDir}/scripts/acmeYang.groovy", "${docDir}/acmeYang-callout.tmp", "adoc-callout", "adoc-end")
        linesBetween("${templatesDir}/scripts/example1Yang.groovy", "${docDir}/example1Yang.tmp", "adoc-begin", "adoc-callout")
        linesBetween("${templatesDir}/scripts/example1Yang.groovy", "${docDir}/example1Yang-callout.tmp", "adoc-callout", "adoc-end")

        // prepare inlcude files from generated yang files
        linesBetween("${docDir}/acme-module_.tmp", "${docDir}/acme-module.tmp", "adocy-begin", "adocy-callout")
        linesBetween("${docDir}/acme-module_.tmp", "${docDir}/acme-module-callout.tmp", "adocy-callout", "adocy-end")
        linesBetween("${docDir}/example1-module_.tmp", "${docDir}/example1-module.tmp", "adocy-begin", "adocy-callout")
        linesBetween("${docDir}/example1-module_.tmp", "${docDir}/example1-module-callout.tmp", "adocy-callout", "adocy-end")

        // asciidoc has to be installed
        def cmd = 'asciidoc -d article -a data-uri -a icons -a iconsdir=/usr/share/asciidoc/images/icons -a toc -a max-width=55em'
        cmd += " -o  ${buildDirDocumentation.toString()}/yangbuilder.html"
        cmd += " ${docDir}/yangbuilder.asciidoc"
        cmd.execute().waitFor()

        // delete generated files
        //delete(fileTree(documentationDir.toString()).include('**/*.tmp'))
}
// http://daniel.gredler.net/2011/08/08/gradle-keeping-libraries-up-to-date/
// Find any 3rd party libraries which have released new versions
// to the central Maven repository since we last upgraded.
task checkLibVersions << {
        def checked = [:]
        allprojects {
                configurations.each { configuration ->
                        configuration.allDependencies.each { dependency ->
                                def version = dependency.version
                                if (version && !version.contains('SNAPSHOT') && !checked[dependency]) {
                                        def group = dependency.group
                                        def path = group.replace('.', '/')
                                        def name = dependency.name
                                        def url = "http://repo1.maven.org/maven2/$path/$name/maven-metadata.xml"
                                        try {
                                                def metadata = new XmlSlurper().parseText(url.toURL().text)
                                                def versions = metadata.versioning.versions.version.collect { it.text() }
                                                versions.removeAll { it.toLowerCase().contains('alpha') }
                                                versions.removeAll { it.toLowerCase().contains('beta') }
                                                versions.removeAll { it.toLowerCase().contains('rc') }
                                                def newest = versions.max()
                                                if (version != newest) {
                                                        println "$group:$name $version -> $newest [$versions]"
                                                }
                                        } catch (FileNotFoundException e) {
                                                logger.debug "Unable to download $url: $e.message"
                                        } catch (org.xml.sax.SAXParseException e) {
                                                logger.debug "Unable to parse $url: $e.message"
                                        }
                                        checked[dependency] = true
                                }
                        }
                }
        }
}