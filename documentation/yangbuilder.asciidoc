yangbuilder
===========
:Author:    Michal Nov√°k
:Email:     bubbles.way@gmail.com
:URL:       https://bitbucket.org/bubbles.way/yangbuilder
:Date:      2012-04-14
:Revision:  0.0.1

This document is written in http://www.methods.co.nz/asciidoc/[AsciiDoc] and converted to the desired format (html, pdf, etc.) 

== Version history

[options="header"]
|======
| Version     | Notes          | Date    | Author
| {revision}  | Initial version| {date}  | {author}
|======

== References

[bibliography]
* [[[yang]]] http://www.yang-central.org[YANG - A Data Modeling Language for the Network Configuration Protocol (NETCONF)]
* [[[RFC6200]]] RFC for http://www.yang-central.org/twiki/pub/Main/YangDocuments/rfc6020.html[YANG - A Data Modeling Language for the Network Configuration Protocol (NETCONF)]
* [[[groovy]]] http://groovy.codehaus.org/[Groovy - dynamic language for JAVA platform]
* [[[nodebuilder]]] https://bitbucket.org/bubbles.way/nodebuilder[Library for creation of groovy builders with plugin support]
* [[[yangbuilder]]] https://bitbucket.org/bubbles.way/yangbuilder[Groovy builder for YANG] - this document describes <<yangbuilder>>
* [[[pyang]]] http://code.google.com/p/pyang/

== Terminology

* *Yang:*  a Data Modeling Language for the Network Configuration Protocol (NETCONF), see <<RFC6200>>
* *Groovy builder:*  http://en.wikipedia.org/wiki/Design_Patterns[builder design pattern] implemented in <<groovy>>, with support for DSL,
  see http://groovy.codehaus.org/Builders[groovy builders]

== License

The <<yangbuilder>> is free software licensed under http://en.wikipedia.org/wiki/MIT_License[MIT Licnense].

------------------
include::LICENSE.tmp[]
------------------

== Introduction

The [[[yang]]] modeling language is used to describe data model of the configuration. In this way it can be compared to the *XSD*, however the syntax is
rather different (more similar *JSON*). 

Syntax of the data model written in the <<yang>> resembles syntax used in a Groovy builders. Groovy builders can be used to create
parent-child oriented data documents like *XML* and thus also <<yang>>.

Compare 

.Yang example from http://www.yang-central.org/twiki/bin/view/Main/YangTutorials[Yang tutorial] (shortened)
----
container timeout {                                             <1>
    leaf access-timeout {                                       <2>
        description "Maximum time without server response";
        type uint32;
    }
    leaf retry-timer {                                          <2>
        description "Period to retry operation";
        type uint32;
    }
}
----
<1> structure parent element
<2> structure member - child element with attributes (e.g. +type+)

to 

.Groovy MarkupBuilder example from  http://groovy.codehaus.org/Creating+XML+using+Groovy%27s+MarkupBuilder[Creating XML] chapter
----
car(name:'HSV Maloo', make:'Holden', year:2006) {               <1>
    country('Australia')                                        <2>
    record(type:'speed', ' Truck with speed of 271kph')         <2>
}
----
<1> structure parent element
<2> structure member - child element with attributes (e.g. +type+, +value+)

NOTE: Here we are comparing similarity of the syntax, not the meaning. The <<yang>> example represents data model,
      the <<groovy>> example represents data model instance (XML with values). With <<groovy>> one can also build *XSD*
      in a same way like *XML*. With *XSD* the meaning would be the same.

NOTE: Because of the syntax similarity, in some Java IDEs (http://netbeans.org/index.html[NetBeans], http://www.jetbrains.com/idea/[Intellij IDEA], http://www.eclipse.org/[Eclipse]) 
      it is possible to use groovy mode to get limited editor support for the <<yang>> files (e.g syntax highlighting) out of the box.

Groovy <<yangbuilder>> allows to create <<yang>> data models with similar syntax as <<yang>>. 

.Yang example from http://www.yang-central.org/twiki/bin/view/Main/YangTutorials[Yang tutorial] (shortened) written in <<groovy>> yangbuilder
----
container('timeout') {                                             <1>
    leaf('access-timeout') {                                       <2>
        description "Maximum time without server response";
        type uint32;
    }
    leaf('retry-timer') {                                          <2>
        description "Period to retry operation";
        type uint32;
    }
}
----
<1> structure parent element
<2> structure member - child element with attributes (e.g. +type+)

As you can see, there is only little syntax difference between <<groovy>> and <<yang>>.
NOTE: <<groovy>> syntax in example above was written to be much similar to <<yang>> as possible. The only difference is brackets around element 
      names containing child elements and apostrophes (or quotation marks). In <<groovy>> you can also omit semicolon. 

With yangbuilder one can use groovy script to generate <<yang>> file. This approach has following pros and cons:

*Pros:*

* more advance reuse (functions, closures, parametrization)
* use of programming language
* similar syntax to yang
* (groovy) support in IDE (navigation, syntax highlighting, formatting)
* plugins

*Cons:*

* additional step - yang file has to be generated
* yangbuilder does not support yang validation (use <<pyang>>)
* advanced reuse can lead to bigger yang files (e.g. generate similar parts several times instead of using yang's +grouping+)

== History

There already existed a <<groovy>> as a part o one project I have worked for in my job (owned by customer).

When I was implementing <<groovy>> builder for http://plantuml.sourceforge.net/[PlantUML] called https://bitbucket.org/bubbles.way/plantumlbuilder[plantumlbuilder],
I have decided to create common builder library <<nodebuilder>> with common support for <<groovy>> builders using
parent-child processing. Than it was relatively easy to base new <<yangbuilder>> on this common library. New <<yangbuilder>> implementation is
completely new, free and supports plugins (provided by <<nodebuilder>>).


=== Dependencies

* <<groovy>> 1.8.0 and newer has to be installed on the system (preferably with +GROOVY_HOME+ set and +$GROOVY_HOME/bin+ in system +PATH+)
* +nodebuilder+ jar file,
* +yangbuilder+ jar file

Note: <<nodebuilder>> and <<yangbuilder>> does not need to be downloaded, if  if <<groovy>> +@Grab+ can be used (PC is connected to Internet)


== Installation

In most cases, there is no need for installation. If you have installed <<groovy>> of version 1.8.0 or newer and Internet connection, the script generating <<yang>> file 
downloads all required dependencies with use of <<groovy>> http://groovy.codehaus.org/Grape[Grape] feature. See +templates/scripts+ directory for example script.
Usually, first run of the script takes some time (downloading dependencies). During second run no dependencies are downloade and Internet connection is not 
needed anymore.

It is also possible to run script or application in regular <<groovy>> way by supplying +classpath+ to the dependent +jar+ files.

TBD footnoteref:[future, This section will be updated in the future to provide more information.]

== Using yangbuilder

See +templates/scripts+ directory to see how write <<yangbuilder>> scripts and generate yang files.
See +templates/project+ directory for sample project that generates several (related) yang files.

=== Example 1

////
Syntax highlighting requires source-highlight package (Ubuntu).
java is used as it is close to groovy syntax
////
.Example groovy script to generate <<Yang>> file based on example from Instant YANG tutorial, section modules
[source,java]
-----------
#!/usr/bin/env groovy                                                                                  //<1>
include::acmeYang.tmp[]
-----------
<1> On Unix (Linux) you can run script to generate <<yang>> file as any other executable script +./<scriptName>.groovy+, 
provided <<groovy>> is installed and exec attribute is set. Alternatively (or on Windows) you can run it as +groovy <scriptname>.groovy+.
include::acmeYang-callout.tmp[]

[source,java]
.Resulting <<yang>> file
-----------
include::acme-module.tmp[]
-----------
include::acme-module-callout.tmp[]
TBD footnoteref:[future]

=== Example 2

.Example groovy script to generate more complex <<Yang>> file
[source,java]
-----------
#!/usr/bin/env groovy
@GrabResolver(name = 'bubbleswayrepo', 
               root = 'https://github.com/bubblesway/bubbleswayrepo/raw/master/releases',
               m2compatible = true)
@Grab(group = 'org.bitbucket.novakmi', module = 'nodebuilder', version = '0.4.0')
@Grab(group = 'org.bitbucket.novakmi', module = 'yangbuilder', version = '0.2.0')

// This script template represents example of usage without any plugin
// create new builder, indent 4 (default is 2)
def builder = new org.bitbucket.novakmi.yangbuilder.YangBuilder(4) 

//name of file to generate
moduleName = "example1-module"   // do not use 'def' for script global variable
//this is example how function can be used by the builder, parameters can be used                      <1>
def makeAddressPort(builder, kind = null) { 
        // in function all nodes have to be prefixed with 'builder.', except for child nodes
        builder.yngbuild("// IPv4 or IPv6 address", indent: true)
        //output depends on parameters, not possible in yang
        builder.leaf("${kind ? kind + '-' : ''}address") { 
                type('inet:ip-address')
        }/* This yang file was generated with groovy YangBuilder on Wed Apr 04 22:53:44 CEST 2012
   see http://bitbucket.org/bubbles.way/yangbuilder */
module acme-module {
  // based on example from Instant YANG tutorial, section modules
  namespace "http://acme.example.com/module";
  prefix acme;

  import yang-types {
    prefix yang;
  }
  include acme-system;

  organization "ACME Inc.";
  contact joe@acme.example.com;
  description
   "The module for entities
    implementing the ACME products.";

  revision 2007-06-09 {
    description "Initial revision.";
  }

}
        builder.yngbuild("// IP port", indent: true)
        builder.leaf("${kind ? kind + '-' : ''}port") {
                type('uint16')
        }
}

builder.module(moduleName) {
        def makeGrouping = { // this is example how closure can be called be used by the builder       <2>
                grouping('addressPort') {
                        makeAddressPort(builder)
                }
        }

        yngbuild("/* This yang file was generated with groovy YangBuilder on ${new Date().toString()}",
                  indent: true)
        yngbuild('   see http://bitbucket.org/bubbles.way/yangbuilder */', indent: true)              //<3>
        yngbuild('') // new line

        namespace "http://bitbucket.org/bubbles.way/yangbuilder"
        prefix "example1"
        yngbuild('')

        'import'('ietf-inet-types') {
                prefix 'inet'
        }
        yngbuild('')

        makeGrouping() // this behaves in the same way as if content of the closure is written here     <4>

        yngbuild('')

        yngbuild("/* neighbor */", indent: true)
        container('neighbor') {
                uses 'addressPort'  // yang grouping reuse
        }
        yngbuild('')

        ['bgp', 'ospf', 'isis', 'rip'].each {k -> // create 3 containers in loop, not possible in yang   <5>
                yngbuild("/* ${k} neighbor */", indent: true)
                container("${k}-neighbor") {
                        // as if content of function is written here, reuse (not possible in yang)       <6>
                        makeAddressPort(builder, k) 
                }
                yngbuild('')
        }

        list('neighbors') { // key leaf can be attribute of list statement
                description('List of neighbors')
                key('neighbor')
                leaf('neighbor') {
                        description "neighbor IP4 or IPv6 address"
                        type 'inet:ip-address'
                }
                leaf('name') {
                        description "neighbor name"
                        type 'string'
                }
        }
}
builder.writeToFile("${builder.getYangName()}.yang")
-----------
<1> closure
<2> function
<3> closure called
<4> indentation
<5> iteration 
<5> function called

[source,java]
.Resulting <<yang>> file
-----------
module example1-module {                                                                        //<1>
    /* This yang file was generated with groovy YangBuilder on Wed Apr 04 22:53:11 CEST 2012
       see http://bitbucket.org/bubbles.way/yangbuilder */

    namespace "http://bitbucket.org/bubbles.way/yangbuilder";
    prefix example1;

    import ietf-inet-types {
        prefix inet;
    }

    grouping addressPort {                                                                      //<2>
        // IPv4 or IPv6 address
        leaf address {
            type inet:ip-address;
        }
        // IP port
        leaf port {
            type uint16;
        }
    }

    /* neighbor */
    container neighbor {
        uses addressPort;
    }

    /* bgp neighbor */                                                                          //<3>
    container bgp-neighbor {
        // IPv4 or IPv6 address
        leaf bgp-address {                                                                      //<4>
            type inet:ip-address;
        }
        // IP port
        leaf bgp-port {
            type uint16;
        }
    }

    /* ospf neighbor */
    container ospf-neighbor {
        // IPv4 or IPv6 address
        leaf ospf-address {
            type inet:ip-address;
        }
        // IP port
        leaf ospf-port {
            type uint16;
        }
    }

    /* isis neighbor */
    container isis-neighbor {
        // IPv4 or IPv6 address
        leaf isis-address {
            type inet:ip-address;
        }
        // IP port
        leaf isis-port {
            type uint16;
        }
    }

    /* rip neighbor */
    container rip-neighbor {
        // IPv4 or IPv6 address
        leaf rip-address {
            type inet:ip-address;
        }
        // IP port
        leaf rip-port {
            type uint16;
        }
    }

    list neighbors {
        description "List of neighbors";
        key neighbor;
        leaf neighbor {
            description "neighbor IP4 or IPv6 address";
            type inet:ip-address;
        }
        leaf name {
            description "neighbor name";
            type string;
        }
    }
}
-----------
<1> indent 4
<2> call to +makeGrouping+
<3> iteration
<4> expanded +makeAddressPort+
TBD footnoteref:[future]

== +yngbuild+ keyword

This keyword echoes it's value directly to the yang file. This is useful if it is not possible to create content of the  <<yang>> file  
with regular builder syntax (e.g. multiline comments). The +yngbuild+ keyword accepts optional attribute +indent+. If its value 
evaluates to +true+, the elements value is indented according to the current nesting level.

Example:

+builder.yngbuild("/* not indented comment */")+

+builder.yngbuild("/* indented comment */", indent:true)+

== <<yang>> elements with special handling for quotes
 
The value of following <<yang>> elements will be automatically surrounded with quotes if needed (string contains any space or tab characters, a semicolon (";"), 
braces ("{" or "}") or comment sequences ("//", "/*", or "*/"). Double quotes are preferred, if string already contains double quotes, singe quotes
are used. 

(See  http://www.yang-central.org/twiki/pub/Main/YangDocuments/rfc6020.html#rfc.section.6.1.3)

* +namespace+
* +key+
* +pattern+
* +prefix+
* +reference+
* +contact+
* +description+
* +presence+
* +organization+

Example: 

+prefix "example1"+

In addition, following  <<yang>> elements accept optional +multiline+ attribute. 

* +reference+
* +contact+
* +description+
* +presence+
* +organization+

If +multiline+ attribute value evaluates to +true+, the elements value is formatted on several lines.

Example:

[source,java]
---------
description('''The module for entities
implementing the ACME products.''', multiline: true)
---------

is expanded to:

[source,java]
---------
description
   "The module for entities
    implementing the ACME products.";
---------

NOTE: Use +yngbuild+ keyword to override this quote handling behavior.
      e.g. +builder.yngbuild("prefix ''example1''", indent: true)+


== Plugins

Plugins can extend +yangbuilder+ with additional functionality according to the +NodeBuilderPlugin+ abstract 
class interface (part of <<nodebuilder>>).

Currently there is only one plugin being part of <<yangbuilder>> package - the +CompactYangPlugin+.


=== CompactYangPlugin

See +CompactYangPlugin.groovy+ (plugin allowing shorter syntax) for example of plugin implementation and 
+CompactYangPluginTest.groovy+ for plugin usage example.

////
 syntax addition table
////


.Example groovy script to generate more complex <<Yang>> file with +CompactYangPlugin+
[source,java]
-----------
#!/usr/bin/env groovy
//Update nodebuilder, yangbuilder version numbers as needed
@GrabResolver(name = 'bubbleswayrepo', 
              root = 'https://github.com/bubblesway/bubbleswayrepo/raw/master/releases',
              m2compatible = true)
@Grab(group = 'org.bitbucket.novakmi', module = 'nodebuilder', version = '0.4.0')
@Grab(group = 'org.bitbucket.novakmi', module = 'yangbuilder', version = '0.2.0')

// This script template represents example of usage with Compact yang plugin 
// (syntax is more different from yang, but more compact)
// create new builder, pass plugin or list of plugins as constructor parameter,
// default indent of 2 has to be specified if we pass plugin (or list of plugins) in constructor 
// (other option is to use builder.registerPlugin(new CompactYangPlugin()))
def builder = new org.bitbucket.novakmi.yangbuilder.YangBuilder(2, new CompactYangPlugin())          // <1>

//name of file to generate
moduleName = "example1-compact-module"   // do not use 'def' for script global variable

//this is example how function can be used by the builder, parameters can be used
def makeAddressPort(builder, kind = null) {
        // in function all nodes have to be prefixed with 'builder.', except for child nodes
        builder.yngbuild("// IPv4 or IPv6 address", indent: true)
        builder.leaf("${kind ? kind + '-' : ''}address", type: 'inet:ip-address',                   
                      description: "IPv4 or IPv6 address") //output depends on parameters
        builder.yngbuild("// IP port", indent: true)
        //with compact plugin 'type' and 'description' as param of element                            // <2> 
        builder.leaf("${kind ? kind + '-' : ''}port", type: 'uint16', description: "IP port")  
}

//module's prefix and namespace as attributes '_nl' means new line
builder.module(moduleName, pnl_namespace:'http://bitbucket.org/bubbles.way/yangbuilder', 
               prefix_nl: 'example1') {                                                               // <3>  
        def makeGrouping = { // this is example how closure can be called be used by the builder
                grouping('addressPort') {
                        makeAddressPort(builder)
                }
        }

        yngbuild("/* This yang file was generated with groovy YangBuilder on ${new Date().toString()}", 
                  indent: true)
        // 'nl:true adds new line (you can also use nl:1, etc.)                                       // <4> 
        yngbuild('   see http://bitbucket.org/bubbles.way/yangbuilder */', indent: true, nl: true)  

        //with compact yang 'prefix' can be added as attribute of import
        //, add new line after ending '}' of import
        'import'('ietf-inet-types', prefix: 'inet', nl: 1)                                            // <5>

        makeGrouping() // this behaves in the same way as if content of the closure is written here
        yngbuild('')

        yngbuild("/* neighbor */", indent: true)
        container('neighbor', pnl: 1, nl: 1) { // pnl - prefix new line-new line before node processing  <6>
                uses 'addressPort'  // yang grouping reuse
        }

        ['bgp', 'ospf', 'isis', 'rip'].each {k -> // create 3 containers in loop, not possible in yang
                yngbuild("/* ${k} neighbor */", indent: true)
                container("${k}-neighbor", description: "${k}-neighbor container", nl: 1) {
                        // same as if content of function is written here, reuse (not possible in yang)
                        makeAddressPort(builder, k) 
                }
        }

        // key leaf can be attribute of list statement
        list('neighbors', key: 'neighbor', description: 'List of neighbors') {                         // <7>
                leaf('neighbor', type: 'inet:ip-address', description: 'neighbor IP4 or IPv6 address')
                leaf('name', type: 'string', description: 'neighbor name')
        }
}
builder.writeToFile("${builder.getYangName()}.yang")
-----------
<1> The plugin is registered with the +builder+ in constructor or with method +registerPlugin+. When registered
    in constructor, it is passed as second attribute after +indent level+ value. It is possible to pass list of
    plugins to register several plugins at once.
<2> +type+ and +description+ can be added as a +leaf+ attribute
<3> +namespace+ and +prefix+ can be added as a +module+ attribute. 
     +pnl_namespace+ means +\n+ before a +namespace+ element,
     +prefix_nl+ means +\n+ after a +prefix+ element
<4> +nl+ attribute evaluating to +true+ means +\n+ after element (no need for +yngbuild('')+)
<5> can be shortened with +prefix_nl+, e.g. +'import'('ietf-inet-types', prefix_nl: 'inet')+
<6> +nl+ attribute evaluating to +true+ means +\n+ before element (no need for +yngbuild('')+)
<7> +key+ can be added as a +list+ attribute

TBD footnoteref:[future]

////
== Implementation

=== Builder 
TBD

=== Plugins

TBD

=== Tests

TBD
////
